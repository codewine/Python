
'''

\d  可以匹配一个数字，
\w  可以匹配一个字符串
.   可以匹配任意字符

\d{3}   表示匹配3个数字，例如'010'；
\s      可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
\d{3,8} 表示3-8个数字，例如'1234567'。

如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\'转义，所以，上面的正则是\d{3}\-\d{3,8}。

要做更精确地匹配，可以用[]表示范围，比如：

[0-9a-zA-Z\_]   可以匹配一个数字、字母或者下划线；
[0-9a-zA-Z\_]+  可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等；
[a-zA-Z\_][0-9a-zA-Z\_]*    可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}  更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
A|B 可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。
^表示行的开头，^\d 表示必须以数字开头。
$表示行的结束，\d$ 表示必须以数字结束。

'''


# re模块

s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成：
# 'ABC\-001'
# 因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：

s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'



import re
r = re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
print(r)


# match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：

test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')

# 切分字符串
# 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：


print('a b   c'.split(' '))
# ['a', 'b', '', '', 'c']
# 嗯，无法识别连续的空格，用正则表达式试试：

# 个空格都可以正常分割。加入,试试：
print(re.split(r'\s+', 'a b   c'))
# ['a', 'b', 'c']
# 无论多少个空格都可以正常分割。

print(re.split(r'[\s\,]+', 'a,b, c  d'))
# ['a', 'b', 'c', 'd']

# 再加入;试试
print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))
# ['a', 'b', 'c', 'd']



# 分组

m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(m)


t = '19:05:30'
m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(m.groups())